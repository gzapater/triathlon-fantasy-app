"""add access_code to races column

Revision ID:
Revises: b247e33d3196
Create Date: 2025-06-25 07:30:07.332485481

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = ''
down_revision = 'b247e33d3196' # Previous head
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('races', schema=None) as batch_op:
        batch_op.add_column(sa.Column('access_code', sa.String(length=36), nullable=True)) # Add as nullable first
        # Populate existing rows with UUIDs. This is a bit tricky in Alembic for cross-DB.
        # For PostgreSQL, we'd ideally use server_default=sa.text('gen_random_uuid()')
        # For SQLite and general approach, populate then alter.
        # However, since the model has a default, new rows are fine.
        # Existing rows will be NULL. If nullable=False is desired, a data migration or app-level backfill is safer.
        # Given the model has nullable=False and a Python default, the DB schema should match.
        # Let's try with nullable=False and server_default for PostgreSQL.

    # Re-doing with nullable=False and server_default, assuming PostgreSQL
    # If this were SQLite only, one might add nullable=True, then run a separate op.execute to fill values,
    # then alter_column to nullable=False.
    # For PostgreSQL:
    op.add_column('races', sa.Column('access_code', sa.String(length=36), nullable=False, server_default=sa.text('gen_random_uuid()')))
    op.create_unique_constraint('uq_races_access_code', 'races', ['access_code'])
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint('uq_races_access_code', 'races', type_='unique')
    op.drop_column('races', 'access_code')
    # ### end Alembic commands ###
